import binascii
import hashlib
import hmac
import os

from fastapi import Request, Response, HTTPException
from starlette.status import HTTP_403_FORBIDDEN, HTTP_400_BAD_REQUEST, HTTP_401_UNAUTHORIZED
from starlette.status import HTTP_307_TEMPORARY_REDIRECT, HTTP_205_RESET_CONTENT

import shopify
from shopify import session_token

from app import config
from app import dao
from app import programs

# https://shopify.dev/apps/auth/oauth/getting-started

shop_access_tokens = {}


class EmbeddedAuthRedirectException(Exception):
    """We can't redirect to the auth page until we pop out of the Shopify iframe.
    The exception handler is in the main module.
    """
    def __init__(self):
        self.redirect_to = "exit_frame.html"


class AccessTokenNotFound(Exception):
    pass


def get_session_from_client_token(request: Request):
    """
    The function decodes the session token from the Authorization header
    and passes along a valid session from it.

    The session token is generated by calls from the Shopify app-bridge
    which is used in our app client.
    """
    try:
        decoded_session_token = session_token.decode_from_header(
            authorization_header=request.headers.get('Authorization'),
            api_key=config.SHOPIFY_CLIENT_ID,
            secret=config.SHOPIFY_SECRET
        )
    except session_token.SessionTokenError as e:
        # Log the error here
        raise HTTP_401_UNAUTHORIZED

    # not sure why the shop has the protocol prefix in this case
    shop_name = decoded_session_token.get("dest").replace("https://", "")
    try:
        access_token, status = shop_access_tokens[shop_name], 200
    except KeyError:
        # get from the database if we need to
        access_token, status = dao.get_shop_access_token(shop_name)
        if status != 200:
            raise AccessTokenNotFound

    return shopify.Session(shop_name, config.API_VERSION, access_token)


def verify_shop_access(request: Request):
    """
    This function is a dependency in the / (home) resource and
    will initiate the store installation flow if we do not have
    an access token.
    """
    # will be appended if needed when checking resource below
    scopes = programs.SCOPES_STAGE_1

    query_params = dict(request.query_params)
    try:
        shop_name = query_params["shop"]
    except KeyError:
        raise HTTPException(status_code=HTTP_400_BAD_REQUEST, detail="could not find shop")

    # fetch the access token if we have it...
    # It would have been set by /auth/callback
    try:
        access_token, status = shop_access_tokens[shop_name], 200
    except KeyError:
        access_token, status = dao.get_shop_access_token(shop_name)

    if status == 200:
        # we have an access code!
        session = shopify.Session(shop_name, config.API_VERSION, access_token)
        shopify.ShopifyResource.activate_session(session)

        try:
            shop = shopify.Shop.current()
            # we have a valid session/shop/code!
            if not request.url.path.startswith("/scope/"):
                # we're good!
                return session

            new_scope = request.url.path.replace("/scope/", "")
            program_shopify = programs.ProgramShopify(shop_name)
            if new_scope in program_shopify.permissions:
                # out token already has the scope, so carry on
                return session

            # new scope = proceed to request permissions
            scopes.append(new_scope)

        except Exception as e:
            # If this happens then we don't have access any more, or our token is no good...
            # TODO: figure out how to catch the proper exception from Shopify:
            # (pyactiveresource.connection.UnauthorizedAccess)
            # so we go through the flow again
            pass

    # We need to reauthenticate with the shop.
    # No code or unauthorized access
    # This is the oauth flow...

    if "embedded" in query_params and query_params["embedded"] == "1":
        # client redirect to same url process
        raise EmbeddedAuthRedirectException

    else:
        # install request needs hmac verification
        verify_hmac(query_params)

        # not embedded so create the auth url and do the redirect
        shopify.Session.setup(
            api_key=config.SHOPIFY_CLIENT_ID,
            secret=config.SHOPIFY_SECRET
        )
        session = shopify.Session(shop_name, config.API_VERSION)

        # get the authorization url
        # TODO: optimize this scopes part...
        state = binascii.b2a_hex(os.urandom(15)).decode("utf-8")
        auth_url = session.create_permission_url(scopes, config.AUTH_CALLBACK_URL, state)

        # SEND THE REDIRECT
        raise HTTPException(
            status_code=HTTP_307_TEMPORARY_REDIRECT,
            headers={'Location':auth_url}
        )


def save_shop_access_token(shop_name, access_token, scope):
    """Pass through function so we don't have direct dao access in the main function
    """
    global tokens
    shop_access_tokens[shop_name] = access_token
    dao.put_shop_access_token(shop_name, access_token)
    dao.update_ix_shop_permission(shop_name, scope)


def verify_hmac(query_params: dict):
    """Verifies hmac value as part of the oath process.
    Documented here:
    https://shopify.dev/apps/auth/oauth/getting-started#step-2-verify-the-installation-request
    """
    hmac_value_received = query_params.pop('hmac')
    print("qp", query_params)

    if hmac_value_received:
        # create the cleaned query string
        cleaned_query = '&'.join([
            '%s=%s' % (key, value)
            for key, value in sorted(query_params.items())
        ])

        # get hmac value to compare
        hmac_value_created = hmac.new(
            config.SHOPIFY_SECRET.encode("utf8"),
            msg=cleaned_query.encode("utf8"),
            digestmod=hashlib.sha256
        ).hexdigest()

        # Compare digests
        print (hmac_value_created, hmac_value_received)
        if not hmac.compare_digest(hmac_value_created, hmac_value_received):
            raise HTTPException(
                status_code=HTTP_403_FORBIDDEN,
                detail="hmac could not be verified"
            )

